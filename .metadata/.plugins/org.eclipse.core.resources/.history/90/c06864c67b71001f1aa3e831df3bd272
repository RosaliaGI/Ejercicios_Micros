#include <msp430.h>

unsigned char secuencia[]={12, 6, 3, 9};  // 1100 0110 0011 1001 (representa el estado de los pines P2.0 a P2.3) (mover stepper)
unsigned char i = 0;

#define TIMER_INCREMENT 62500
unsigned char motor_moving = 1;

void delay (unsigned short tiempo){
    for (i=0;i<=tiempo;i++){
        TA0CCR0=TAR+5000;
        while ((TA0CCTL0 & 1) == 0);

        TA0CCTL0 &= ~(1<<0);
    }
}

int main(void){
    WDTCTL = WDTPW | WDTHOLD;   // stop watchdog timer
    // GPIO
    P2DIR = 0x0F;               // 0b0000 1111, 15, BIT3 + BIT2 + BIT1 + BIT0  Ponemos los pines como salida

    // Config timer
    TA0CTL = (2<<8)+(2<<4)+(2<<6);      // Seleccionamos SMCLK,  Modo continuo, divider 8

    TA0CCTL0 |= (1<<4);                 // Habilitador local para CCR0 la interrupción
    TA0CCR0 = TAR+5000;

    //TA0CCTL1 |= (1<<4);         // Habilitador local
    //TA0CCR1 = TAR + TIMER_INCREMENT;

    __bis_SR_register(GIE);     // Globar interrup enable (biS prender biC apagar)

    while(1){
        if ((P1IN & (1<<3)) !=0){       // Botón de usuario P1.3 (si está presionado secuencia es ascendente)
            P2OUT = secuencia[i++%4];   // %4 hace que el valor siempre esté entre 0 y 3
        } else {                        // secuencia descendente
            P2OUT = secuencia[i--%4];
        }
        delay(1);
    }
}

