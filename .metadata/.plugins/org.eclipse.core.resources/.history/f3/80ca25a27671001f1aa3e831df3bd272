#include <msp430.h>

#define TIMER_INCREMENT 62500
#define INTERRUPT_COUNT_10SEG 20
#define INTERRUPT_COUNT_5SEG 10

unsigned char secuencia[]={12, 6, 3, 9};  // 1100 0110 0011 1001 (representa el estado de los pines P2.0 a P2.3) (mover stepper)
unsigned char  i = 0;
unsigned char interrupt_count = 0;        // Contador de interrupciones para llegar a 10



#pragma vector=TIMER0_A0_VECTOR
__interrupt void Timer_A0 (void)
{
    TA0CCTL0&=~(1<<0);                  // Apagamos bandera, 0 en bit menos significativo
    TA0CCR0 = TAR + TIMER_INCREMENT;    // Incremento CCR0 .5 seg

    interrupt_count++;

    if (interrupt_count == INTERRUPT_COUNT_10SEG){   // Si fueron los 20 .5 seg, ya se cumplen los 10 s
        interrupt_count = 0;            // Reiniciamos variable
        P2OUT = 0;                      // Detengo el motor
        TA0CCR1 = TAR + TIMER_INCREMENT // Valor de clock mas .5 s
    }
}

#pragma vector=TIMER0_A1_VECTOR
__interrupt void Timer_A1 (void)
{
    TA0CCTL1 &=~(1<<0);                  // Apagamos bandera, 0 en bit menos significativo

    interrupt_count++;

    if (interrupt_count == INTERRUPT_COUNT_5SEG){   // Si fueron los 10 .5 seg, ya se cumplen los 5 s
        // Seguimos con movimiento de motor
    }
}

int main(void){
    WDTCTL = WDTPW | WDTHOLD;           // stop watchdog timer
    // GPIO
    P2DIR = 0x0F;                       // 0b0000 1111, BIT3+BIT2+BIT1+BIT0 (se configuran los pines 0, 1, 2, 3 de Puerto 2)

    // Settings timer
    TA0CTL = (2<<8)+(2<<4)+(2<<6);      // Seleccionamos SMCLK,  Modo continuo, divider 8
    TA0CCTL0 |= (1<<4);                 // Habilitador local para CCR0 la interrupción
    TA0CCTL1 |= (1<<4);

    TA0CCR0 = TAR + TIMER_INCREMENT;    // EL valor que tengo en clock mas .5 segs

    __bis_SR_register(GIE);             // Global interrupt enable (biS prender biC apagar)

    while(1){
        // Movimiento de motor
        if ((P1IN & (1<<3)) !=0){       // Botón de usuario P1.3 (si está presionado secuencia es ascendente)
            P2OUT = secuencia[i++%4];   // %4 hace que el valor siempre esté entre 0 y 3
        } else {                        // secuencia descendente
            P2OUT = secuencia[i--%4];
        }
    }
}
