#include <msp430.h>

#define TIMER_INCREMENT 62500
#define INTERRUPT_COUNT_10SEG 20
#define INTERRUPT_COUNT_5SEG 10

unsigned char secuencia[]={12, 6, 3, 9};  // 1100 0110 0011 1001 (representa el estado de los pines P2.0 a P2.3) (mover stepper)
unsigned char  i = 0;


#pragma vector=TIMER0_A0_VECTOR
__interrupt void Timer_A0 (void)
{
    TA0CCTL0&=~(1<<0);              // Apagamos bandera, 0 en bit menos significativo
    TA0CCR0 = TAR + 5000;

    if((P1IN & (1<<3))!= 0)         // revisamos si estamos presionando el botón botón está en P1.3
        P2OUT = secuencia[i++%4];
    else
        P2OUT = secuencia[i--%4];
}


int main(void)
{
    WDTCTL = WDTPW | WDTHOLD;   // stop watchdog timer
    // GPIO
    P2DIR = 0x0F;               // 0b0000 1111, 15, BIT3 + BIT2 + BIT1 + BIT0  Ponemos los pines como salida

    // Config timer
    TA0CTL = (2<<8)+(2<<4)+(2<<6);     // Seleccionamos SMCLK (1MHz/1us)(10 apartir de la posición 8), Modo continuo (10 apartir de posición 4)
    TA0CCTL0 |= (1<<4);         // Habilitador local para CCR0 la interrupción, Si pongo el or, solo se cambia el bit que quiero, no como =
    TA0CCR0 = TAR+5000;         // 5 milisegundos


    __bis_SR_register(GIE);     // Globar interrup enable (biS prender biC apagar)

    while(1);
}
